

From: Schneidereit, James 
Sent: Wednesday, May 20, 2015 2:18 PM
To: Schallerer, Evan <Evan.Schallerer@oregonstate.edu>
Cc: Lepinski, Alex - CASS <alex.lepinski@bus.oregonstate.edu>
Subject: People Pro

==MVC5 People Pro Training==

Create a simple MVC web application to track the Buildings, Departments, and Employees associated with an imaginary company. 

The instructions provided are intentionally vague.
If you find yourself spinning your wheels for too long, ask around for some help!

Certain files will have things that you are not expected to come up with on your own, look for them in the solution overview, denoted by an *.

FLPeoplePro: first initial, last initial

====1. Solution Overview====
{{{{
|- FLPeoplePro (Solution)
                |- FLPeoplePro (Web Application Project)
                                |- Controllers
                                                \ HomeController.cs
                                                \ BuildingController.cs
                                |- Views
                                                |- Building
                                                                \ Create.cshtml
                                                                \ Delete.cshtml
                                                                \ Details.cshtml
                                                                \ Edit.cshtml
                                                                \ Index.cshtml
                                                |- Home
                                                                \ Index.cshtml
                |- FLPeopleProDB (SQL Server Database Project)
                                |- Post
                                                \
                                |- dbo
                                \FLPeopleProDB.publish.xml
                |- FLPeopleProLib (C# Class Library Project)
                                |- DataAccess
                                                \ PeopleProRepo.cs *
                                                \ IPeopleProRepo.cs
                                                \ PeopleProContext.cs
                                                \ IPeopleProContext.cs
                                |- Models
                                                \ Building.cs
                                |- Util
                                                \ Extensions.cs
                                                \ CacheManager.cs
                                \ PeopleProModel.edmx
}}}}

====2. Setup Solution====
# Create New Project
#* ASP.NET Web Application
#* name: FLPeoplePro
#* Add to source control
#* Select empty template and add references and folders for MVC
#* Make sure you don't push this project to Azure
# Setup the two additional projects shown in the Solution Overview (the database and library)

====3. Setup an Empty Databse====
# Open SQL Server 2014 Management Studio
# Connect to .
# Expand Databases
# Right click databases, new database, name it FLPeoplePro

====4. Create Data Model in Library====

=====4.1 Setup the edmx file=====
# Add an ADO.NET Entity Data Model to the library project
#* Name it FLPeopleProModel
#* Choose Empty EF Design
#* Use Entity Framework 6

# Once you have the .edmx file, we'll change the namespace that it will use for code generation
#* Right click the .edmx file and select properties
#* change Custom Tool Namespace to: FLPeopleProLib.Models, this way any partial classes you create in the Models folder will have matching namespaces

=====4.2 Create the model=====
# Now we'll create the model, open the .edmx
#* Right click the designer screen and add a new entity, name it Building
#* Do this for Department and Employee

# Now we'll create scalar properties for each entity
#* Right click the given entity and add scalar properties, a building should have an Id, Address, and a Name?

# Finally we'll setup the associations between objects. Buildings hsould have one or more Departments etc.
#* Right click Building add new association and ensure the multiplicity makes sense

=====4.3 Generate the database from the model=====
# Right click the EF Designer and select "Generate Database from Model"
#* Select "New Connection", Continue, Server name: ".", Database name: "FLPeoplePro"
#* At the top of the opened .sql file, click the green arrow to execute the script. You should now have a database, see for yourself in the management studio! (You might need to explicitely tell visual studio to connect to your local database instance before you click execute)

=====4.4 Create metadata in library=====
In FLPeopleProLib\Models create a class with the same name as each class that was generated by the EF Designer.
# Change the keywords for these new files, we want them to be public partial classes.
# In each of these files add a class called ClassNameMetaData. e.g. BuildingMetaData
#* In this class we want to add attributes for the fields found in the original class definition. For example, the Id property should be required so well add a {{[Required]}} attribute above puglic int Id { get; set; }

Add appropriate attributes for all of the models, you might want to try a regular expression for phone number or email for employees.

====5. Setup Web App Project====
Now that the model is setup, we can setup the views and controllers

=====5.1 Context / Repository=====
This is where all CRUD operations will go. We want an interface for both the repo and the context. See the file names in the solution overview.

@@public interface IPeopleProRepo : IDisposable
{
                #region Employees
                
                IEnumerable<Employee> GetAllEmployees();

                Employee GetEmployeeById(int id);

                void SaveEmployee(Employee employee);

                void DeleteEmployee(Employee employee);

                #endregion
                ...
}@@

@@public sealed class PeopleProRepo : IPeopleProRepo
{
                private readonly IPeopleProContext m_context;
                private bool m_disposed;

                public PeopleProRepo() : this(new PeopleProContext()) { }

                public PeopleProRepo(IPeopleProContext context)
                {
                                m_context = context;
                }

                public IEnumerable<Employee> GetAllEmployees()
                {
                                return m_context.Employees;
                }

                public Employee GetEmployeeById(int id)
                {
                                return GetAllEmployees().SingleOrDefault(e => e.Id == id);
                }

                public void SaveEmployee(Employee employee)
                {
                                DoSave(m_context.Employees, employee, employee.Id, e => e.Id == employee.Id);
                }

                public void DeleteEmployee(Employee employee)
    {
        if (employee == null || employee.Id <= 0)
        {
            return;
        }

        m_context.Employees.Remove(employee);
        m_context.SaveChanges();
    }

    // Departments

    // Buildings

    /// <summary>
    /// Borrowed from small fruits!
    /// </summary>
    private void DoSave<T>(IDbSet<T> dbset, T entity, int entityId, Func<T, bool> predicate) where T : class
    {
        if (entity == null)
       {
            throw new ArgumentNullException(entity.GetType().Name);
        }

        if (entityId <= 0)
        {
            dbset.Add(entity);
        }
        else
        {
            var old = dbset.SingleOrDefault(predicate);
            entity.CopyTo(old);
        }

        m_context.SaveChanges();
    }
    #endregion

    #region Disposal

    /// <summary>
    /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
    /// </summary>
    public void Dispose()
    {
        this.Dispose(true);
        GC.SuppressFinalize(this);
    }

    /// <summary>
    /// Releases unmanaged and - optionally - managed resources.
    /// </summary>
    /// <param name="isDisposing"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1031",
        Justification = "Swallows general exceptions, to prevent the service from being disabled.")]
    private void Dispose(bool isDisposing)
    {
        if (!m_disposed)
        {
            try
            {
                // Called from the IDisposable Method
                // Nothing happens when isDisposing is false, since we don't have unmanaged resources
                if (isDisposing)
                {
                    try
                    {
                        if (m_context != null)
                        {
                            m_context.Dispose();
                        }
                    }
                    catch (Exception)
                    {
                        // This is intended to swallow up any exceptions to prevent the service from being crashing.
                    }
                }
            }
            finally
            {
                m_disposed = true;
            }
        }
    }
}@@

@@public interface IPeopleProContext : IDisposable
{
                IDbSet<Building> Buildings { get; set; }
                ...
                int SaveChanges();
}@@

@@interal class PeopleProContext : DbContext, IPeopleProContext
{
                public IDbSet<Building> Buildings { get; set; }
}@@

=====5.2 Controllers=====
# Add an appropriately named controller for every model (see solution overview for guidance)
#* Ensure that you use MVC 5 Controller with read/write actions
# Add an additional controller for Home, just the empty controller all you will need is {{Index View()}}

The beginning of your controller should look something like this:

@@public class BuildingController : Controller
{
                private IPeopleProRepo m_repo;
                public BuildingController() : this(new PeopleProRepo()) { }
                public BuildingController(IPeopleProRepo repo)
                {
                                m_repo = repo;
                }

                //flesh out the controller actions

                public ActionResult Index()
                {
                                IEnumerable<Building> buildings = m_repo.GetAllBuildings();

                                if (buildings.IsNullOrEmpty())
                                {
                                                //If there are no buildings, we should provide the ability to create them?
                                                return RedirectToAction("Create");
                                }

                                //paginate buildings, what if there are 10000, do we want the user to scroll through all of that?
                                //look up IPagedList<T>

                                return View(buildings)
                }

                public ActionResult Details(int id)
                {
                                //should get a building by an id and return the View of it.
                                //what if the building is null? probably redirect to Index
                }

    // GET: Building/Create
    public ActionResult Create()
    {
                //for models that require other objects, like departments and employees you can add a select list to use for a dropdown:
                //ViewBag.Buildings = new SelectList(m_repo.GetAllBuildings(), "Id", "Name");
        return View();
    }

    // POST: Building/Create
    [HttpPost]
    public ActionResult Create(Building building)
    {
        if (building == null)
        {
            return RedirectToAction("Create");
        }

        if (ModelState.IsValid)
        {
            m_repo.SaveBuilding(building);
            return RedirectToAction("Index");
        }

        return View(building);
    }

    //edit is similar to create, but isntead the Get should get the buildign to edit and pass that into the view
    //same with delete, you'll need to call the appropriate repo functions though
}@@

=====5.3 Views=====
Add views in the appropriate directories (see directory list) for every action defined in the controller:

# Create a diectory for Building
#* right click add view, view name: create, template: create, model class: building

#For the index files for each controller I used the list template



====This might be helpful====

@@public static class Extensions
{
    /// <summary>
    /// Borrowed from small fruits. Determines whether the target sequence is null or empty.
    /// </summary>
    public static bool IsNullOrEmpty<T>(this IEnumerable<T> target) where T : class
    {
        return target == null || !target.Any();
    }

    /// <summary>
    /// Borrowed from small fruits.
    /// </summary>
    public static void CopyTo<TOriginal, TOther>(this TOriginal source, TOther destination) where TOriginal : class
    {
        if (destination == null || source == null)
        {
            return;
        }

        var sourceType = typeof(TOriginal);
        var destinationType = typeof(TOther);

        var sourceProperties = CacheManager.GetPropertyInfoForType(sourceType)
                                           .Where(t => t.CanWrite)
                                           .ToList();
        var destinationProperties = CacheManager.GetPropertyInfoForType(destinationType)
                                                .Where(t => t.CanWrite)
                                                .ToList();

        foreach (var prop in sourceProperties)
        {
            PropertyInfo destinationProperty = destinationProperties
                                               .SingleOrDefault(u => u.Name == prop.Name &&
                                                                u.PropertyType == prop.PropertyType);

            if (destinationProperty != null)
            {
                destinationProperty.SetValue(destination, prop.GetValue(source));
            }
        }
    }
}@@

@@class CacheManager
{
    private static Dictionary<Type, XmlSerializer> m_serializerCache;
    // essentially a mutex
    private static object m_locker = new object(); 
    private static Dictionary<Type, PropertyInfo[]> m_reflectionCache;

    public static XmlSerializer GetSerializerForType(Type type)
    {
        XmlSerializer result = null;

        lock (m_locker)
        {
            if (m_serializerCache == null)
            {
                m_serializerCache = new Dictionary<Type, XmlSerializer>();
            }

            if (m_serializerCache.ContainsKey(type))
            {
                result = m_serializerCache[type];
            }
            else
            {
                result = new XmlSerializer(type);
                m_serializerCache.Add(type, result);
            }
        }

        return result;
    }

    public static PropertyInfo[] GetPropertyInfoForType(Type type)
    {
        PropertyInfo[] result = null;

        lock (m_locker)
        {
            if (m_reflectionCache == null)
            {
                m_reflectionCache = new Dictionary<Type, PropertyInfo[]>();
            }

            if (m_reflectionCache.ContainsKey(type))
            {
                result = m_reflectionCache[type];
            }
            else
            {
                result = type.GetProperties();
                m_reflectionCache.Add(type, result);
            }
        }

        return result;
    }
}@@
